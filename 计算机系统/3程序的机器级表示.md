![24667b5c06e6d8afb303a157a4bef4b](https://cdn.jsdelivr.net/gh/liyu6688/images@main/24667b5c06e6d8afb303a157a4bef4b.jpg)

![9d6d3ecf79cf819890452cfae863e44](https://cdn.jsdelivr.net/gh/liyu6688/images@main/9d6d3ecf79cf819890452cfae863e44.jpg)Intel用16 位表示字，32位表示双字，64 位表示四字

objdump反汇编

64位处理器，寄存器的位数就是64

# 程序的机器级表述

+ 编译之后的文件
  + 白字是跟链接器链接的要求
  + ![屏幕截图 2025-05-14 095612](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20095612.png)
  + ![屏幕截图 2025-05-14 100434](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20100434.png)

# 寄存器与数据传送

### 通用寄存器作用

+ rdi和rsi会来保存函数传递的第一个参数和第二个参数
+ rax是返回值
+ 寄存器的一些不同的名字实际是存储在相同的寄存器里面只是不同的位数

![屏幕截图 2025-05-14 095822](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20095822.png)

![屏幕截图 2025-05-14 100725](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202025-05-14%2520100725.png)

![屏幕截图 2025-05-14 100734](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20100734.png)

![屏幕截图 2025-05-14 100750](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20100750.png)

![屏幕截图 2025-05-15 161057](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20161057.png)

### 调用者保存寄存器，被调用者保存寄存器

+ ![屏幕截图 2025-05-14 100059](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20100059.png)

  

  ![屏幕截图 2025-05-14 100111](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20100111.png)

+ 

### 程序解读

![屏幕截图 2025-05-14 100612](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%25E5%25B1%258F%25E5%25B9%2595%25E6%2588%25AA%25E5%259B%25BE%25202025-05-14%2520100612.png)

![屏幕截图 2025-05-14 113736](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20113736.png)

### 汇编指令

![屏幕截图 2025-05-14 101239](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20101239.png)

##### 内存引用

+ 就是寄存器带括号（%rbx），和M[addr]
+ 有效地址是，立即数+ 基址寄存器+变址寄存器*比例因子
+ ![屏幕截图 2025-05-14 101507](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20101507.png)

变式

![屏幕截图 2025-05-14 101802](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20101802.png)

##### move指令

+ move 源操作数 目的操作数![屏幕截图 2025-05-14 102224](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20102224.png)
+ 源操作数
  + 立即数
  + 寄存器
  + 内存引用
+ 目的操组数
  + 寄存器
  + 内存引用

+ x86-64处理器有个限制，不能都是内存地址

  + 所以从一个地址写到另一个地址
  + move memory register
  + move register memory

+ move的第一个数是立即数的话只能是32位，然后扩展成64位

  + 引入movabsq，源操作数是64位，但目的只能是寄存器

  + ![屏幕截图 2025-05-14 102249](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20102249.png)

    ![屏幕截图 2025-05-14 104214](./../c%E7%9B%98%E7%A7%BB%E8%BF%87%E6%9D%A5%E7%9A%84/%E5%9B%BE%E7%89%87/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20104214.png)

    ![屏幕截图 2025-05-14 104050](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20104050.png)

##### 源操作数比目的操作数位数少的话

+ 零扩展
+ 符号扩展

![屏幕截图 2025-05-14 104447](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20104447.png)

![屏幕截图 2025-05-14 104454](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20104454.png)



# 栈与数据传送指令

+ 栈底是高位地址

+ 栈的特性，弹出的数据永远是最近被压入的且仍在栈中

+ 程序的运行时，数据啥的就存在栈中

+ ![屏幕截图 2025-05-14 114728](./../c%E7%9B%98%E7%A7%BB%E8%BF%87%E6%9D%A5%E7%9A%84/%E5%9B%BE%E7%89%87/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20114728.png)

  ![屏幕截图 2025-05-14 114751](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20114751.png)

  其实pop完成之后数据仍然是存在的，直到下一次数据数据写入被覆盖

# 算术和逻辑运算指令

### leaq

+ 加载地址 leaq s  d，x86-64上地址长度都是四位，所以没有其他的leaw啥的
+ 并不是读取地址的内容，但是计算的时候是把寄存器里面的值拿出来计算
+ ![屏幕截图 2025-05-14 115108](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20115108.png)
+ 计算加减
  + ![屏幕截图 2025-05-14 135638](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20135638.png)

### 操作指令

![屏幕截图 2025-05-14 121614](./../c%E7%9B%98%E7%A7%BB%E8%BF%87%E6%9D%A5%E7%9A%84/%E5%9B%BE%E7%89%87/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20121614.png)

![屏幕截图 2025-05-14 121602](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20121602.png)

### 移位

![屏幕截图 2025-05-14 121642](./../c%E7%9B%98%E7%A7%BB%E8%BF%87%E6%9D%A5%E7%9A%84/%E5%9B%BE%E7%89%87/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20121642.png)

![屏幕截图 2025-05-14 140519](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20140519.png)

![屏幕截图 2025-05-14 140504](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20140504.png)

![屏幕截图 2025-05-14 135638](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20135638.png)

# 指令和条件码

+ 条件码寄存器，CPU来维护，长度是单个比特位
+ 描述了最近执行的操作的指令
+ cmp类似sub，减法指令操作，根据两个操作的差来设置条件码
+ test类似and，只设置条件码寄存器的值，不会设置得数的

### 常见的条件码

+ CF，
  + 最高位产生进位
  + 检查无符号数字的溢出
+ ZF
  + 最近的操作结果是0
+ SF
  + 最近的操作结果小于0
+ OF
  + 溢出标志
  + 正溢出和负溢出
  + 符号数字的溢出

### 题目

![屏幕截图 2025-05-14 145504](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20145504.png)

![](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20145618.png)

+ 小于是SF和OF 的异或
+ 小于shcmp根据a-b的差来设置SF和OF
+ ![屏幕截图 2025-05-14 145722](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20145722.png)

# 跳转指令和循环

##### 数据的条件转移和控制的条件转移有什么区别吗？

数据的条件转移和控制的条件转移有以下区别：

转移依据

• 数据的条件转移：通常依据数据本身的特定值或数据之间的关系来决定是否进行转移。例如，当某个数据寄存器中的值大于特定阈值时，进行程序流程的转移。

• 控制的条件转移：更多地基于程序的控制状态或控制信号来决定转移。比如，根据指令执行后的标志位状态（如进位标志、零标志等），或者根据程序中特定的控制变量的值来判断是否进行转移。

虽然两者有所区别，但在实际的程序设计中，它们常常相互配合，共同实现复杂的程序逻辑和控制流程。





#### 就比如说， if a 大于 b，这就是一个控制条件的转移。但是 if a 大于 5，这就是一个数据条件的转移，对吗？

这种说法不太准确。

在“if a大于b”和“if a大于5”中，==都是根据特定的条件来决定程序的执行流程，都属于条件判断语句引发的控制转移==。

“if a大于b”是基于两个变量之间的关系进行条件判断，“if a大于5”是基于变量与常量之间的关系进行条件判断。它们本质上都是通过对条件的评估来决定是否执行特定的代码块，重点在于控制程序的流向，而不是简单地将其区分为控制条件转移和数据条件转移。通常在编程中，统一将它们归为条件控制结构，用于根据不同的条件来控制程序的执行路径。



#### 那是怎么做呢？什么是数据条件的转移呢？ If a 等于 5 算是数据条件的转移吗？或者是说 If a，这算是一个数据条件的转移吗？

在编程中，数据条件的转移通常是指根据数据的值来决定程序执行的路径。

if a等于5

这是一==个典型的数据条件转移==。当程序执行到这个if语句时，会检查变量a的值是否等于5。如果等于5，就会执行if语句块中的代码，否则就会执行else语句块（如果有else的话）或跳过if语句块继续执行后面的代码。这就是根据数据a的值来控制程序流程的转移。

if a

这种情况不太明确，如果a是一个布尔类型的变量，那么if a就是根据a的布尔值（True或False）来决定程序流程，这也属于数据条件转移。但如果a是其他类型，比如数字、字符串等，在不同编程语言中，if a的含义和行为可能不同。例如在Python中，非零数字、非空字符串等会被视为True，零、空字符串等会被视为False，然后根据这个隐含的布尔值来进行条件判断和程序流程控制，这也可以看作是一种数据条件转移。但如果在一些其他语言中，这样的写法可能会引发错误，因为不能直接将非布尔类型的值用于if条件判断。

总的来说，数据条件转移就是根据数据的值（包括各种数据类型所代表的逻辑值）来决定程序下一步执行的方向，通过if等条件判断语句来实现。

#### 就是，主要是说它是跟数据进行比较，它就一般是数据的条件转移。然后跟控制标志位进行比较的话，一般就是控制的条件转移，对吗？

这种说法有一定的合理性，但并不完全准确。

当与数据进行比较时，比如if a > 5，是根据变量a所存储的数据值与常量5进行比较来决定程序流程，这可以称为数据条件转移，因为判断依据是具体的数据内容。

而与控制标志位进行比较，例如if flag == True，其中flag是一个用于控制程序流程的标志变量，通常是布尔类型，这种情况更多地体现了对程序流程的直接控制，可称为控制条件转移。标志位一般用于表示某种状态或控制逻辑，通过对它的判断来决定程序下一步的走向，更侧重于对程序整体流程的把控。

然而，这种区分也不是绝对的。在实际编程中，无论是数据条件转移还是控制条件转移，都是通过条件判断来实现对程序执行路径的控制，本质上都是控制程序流程的手段。而且，有些情况下数据和控制标志位的界限也并非十分清晰，例如一个变量既可以存储数据，也可以作为某种状态的标志来控制程序流程。



#### 就是说大于、小于是控制的转移，然后等于的话是数据的转移，是吗？

这种说法不准确。大于、小于、等于在编程的条件判断中，==都用于实现控制转移==，而不是简单地将等于归为数据转移，将大于、小于归为控制转移。

在编程语言里，像if语句配合大于（>）、小于（<）、等于（==）等比较运算符，都是根据条件表达式的结果来决定程序执行的路径，也就是控制程序的流程转移。比如if(a > 5)、if(a < 10)、if(a == 3)，无论使用哪种比较运算符，都是在进行条件判断，当条件满足时执行相应代码块，不满足则执行其他分支或跳过，都是在控制程序的走向，属于控制转移的范畴。它们本质上都是基于数据的条件来实现对程序流程的控制，而不是将其进行不恰当的区分。

#### ，那数据条件的转移和控制条件的转移，和基于条件的传送代码和基于跳转指令的代码，它们之间就是有那种关系吗？

数据条件转移和控制条件转移主要是从==条件判断==的角度来分类，而基于条件的传送代码和基于跳转指令的代码是从==代码==实现的角度来描述，它们之间有一定的关联和区别。

关联

• 数据与控制条件是基础：无论是基于条件的传送代码还是基于跳转指令的代码，通常都需要依据数据条件或控制条件来决定是否执行相应的传送或跳转操作。例如，在if(a>5)条件成立时执行goto label这样的跳转指令，这里a>5就是数据条件。

• 目的都是控制流程：数据条件转移和控制条件转移通过判断条件来决定程序流程，基于条件的传送代码和基于跳转指令的代码也是为了改变程序的执行顺序，实现不同的逻辑功能，都是为了对程序的运行流程进行控制。

区别

• 关注重点不同：数据条件转移和控制条件转移更关注条件本身的性质，即判断是基于数据值还是控制标志等；而基于条件的传送代码和基于跳转指令的代码更关注具体的代码实现方式，是通过数据传送还是跳转指令来实现流程控制。

• 实现方式多样：数据条件转移和控制条件转移主要通过if - else、switch - case等条件判断语句来实现；而基于条件的传送代码可能涉及到根据条件将数据从一个地方传送到另一个地方，基于跳转指令的代码则使用goto、函数调用与返回等方式来改变程序执行的位置，实现方式更为具体和多样化。



#### 就是基本循环，就是比如 while、do while，都是那种跳转那个指令，对吗？然后是不是说，就是可以就是把它们就是换成那种基于条件传送的指令啊？

while和do - while循环与跳转指令有一定关联，但并不完全等同于跳转指令。它们可以通过一些方式实现类似基于条件传送的效果，但不能简单地直接替换成基于条件传送的指令。以下是具体分析：

while和do - while循环与跳转指令的关系

• 包含跳转逻辑：while和do - while循环在执行过程中，当==条件满足时会不断重复执行循环体，这背后涉及到类似跳转==的逻辑，即程序会跳回到循环体开始的位置重新执行。但它们不仅仅是简单的跳转，还包含了条件判断等其他操作。

与基于条件传送指令的转换可能性

• 理论上的转换思路：可以将循环中的条件判断看作是一种条件，当条件满足时，将相关数据进行处理和“传送”（比如将计算结果赋值给其他变量等），然后通过某种方式模拟循环的跳转，以实现类似循环的功能。例如，使用if语句结合goto语句来模拟while循环，但这种方式在实际编程中很少使用，因为它会使代码结构变得复杂且难以维护。

• 实际限制：while和do - while循环结构清晰，能方便地处理重复性任务，而基于条件传送的指令通常更侧重于数据的传输和处理，很难直接构建出像循环那样具有明确重复执行和条件判断逻辑的结构。并且，高级编程语言中的循环结构经过了优化，能更好地处理边界情况和提高执行效率，强行用基于条件传送的指令来替换会破坏代码的可读性和可维护性。

while和do - while循环与跳转指令有相似之处，但不能简单地等同于跳转指令，也很难直接替换为基于条件传送的指令。在实际编程中，应根据具体需求选择合适的结构和指令来实现功能。

![689420a22330d32c7fdae751372d215](https://cdn.jsdelivr.net/gh/liyu6688/images@main/689420a22330d32c7fdae751372d215.jpg)

![屏幕截图 2025-05-14 145722](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20145722.png)

![屏幕截图 2025-05-14 145952](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20145952.png)

![屏幕截图 2025-05-14 145946](./../c%E7%9B%98%E7%A7%BB%E8%BF%87%E6%9D%A5%E7%9A%84/%E5%9B%BE%E7%89%87/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-14%20145946.png)

# 过程（函数调用）

+ 实现一个程序需要很多功能切分，就是定义很多函数，所以需要函数调用

+ 面向过程的那个过程，提供封装函数的方式，就是定义接口，就可以隐藏具体实现

+ 对于每一个程序，内存中有个程序栈

  + 当函数p调用函数q，他的栈会分为

    + 之前的栈
    + p的栈
    + 之后的栈

  + 栈里面有

    + 局部变量

    + 超过六个寄存器数量的参数，这个叫栈帧，必须是八个字节的倍数（好像是针对64位，这不8*8=64吗）

      + ![](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20163328.png)
      + x1-4是局部变量
      + arg是参数，超过六个用栈保存

    + 地址引用 的参数

      + ```c
        int a(int*b int*c){
            d=*c+*b;
            
        }
        int main{
            int e;
            int f;
            a(&e,&f);
        }
        定义的那两个星号是指明这个是指针，就是这个指针存的地址里面的数字
        那个&是指传入地址，e和f就是int类型的数字
        ```

        

+ 函数p调用q的时候，

  + 会有return adress压入栈，指明结束之后从那个地址开始，这个是call完成，不是push
  + 和把q的入口内存给到rip

+ 注意这些函数用的是同一堆通用寄存器，所以要防止不同的 函数把其他函数放在寄存器里面的值给覆盖

  + ![屏幕截图 2025-05-15 163530](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20163530.png)

  + 先把要保留p的参数的寄存器压栈，

  + 他到最后是 pop 了 RBX 和 RBP，可是他原先的那个 RBP 里面不是存出了 X 吗？那 X 不就是被那个原先的 RBP 的值覆盖了吗？

  + 在这个过程中不会出现 x 被覆盖的情况。

    函数执行流程及寄存器值变化分析

    1. 函数开始：
      当函数 P 开始执行时，%rdi 存放参数 x ，%rsi 存放参数 y 。然后执行 movq %rdi, %rbp ，此时 %rbp 保存了一份 x 的副本 。接着执行其他指令，包括调用函数 Q 等操作。
    2. 函数返回前：
      在执行 popq %rbp 恢复 ==%rbp 原始值之前，x 的值已经在函数执行过程中使用过了。比如函数中调用 Q 函数等操作可能会基于保存的 x 值进行计算等==。而且，==x 的原始值始终在 %rdi 寄存器中==（在没有后续指令修改 %rdi 中 x 值的情况下 ），即使 %rbp 恢复到原始值，也不会影响 %rdi 中 x 的值。

    + pushq %rbp 和 popq %rbp 这对操作主要是为了保护函数调用前 %rbp 寄存器的值，以便函数返回后，调用者的执行环境能恢复到调用该函数之前的状态。
    + 这里保存和恢复 %rbp 寄存器值，和函数参数 x 在寄存器中的保存与使用是==不同的逻辑，各自承担不同的功能，不会相互干扰== 。

  ◦ pushq %rbp 和 pushq %rbx 这两条指令执行时，栈指针 RSP 是会自动移动的 。在x86 - 64架构中，pushq 指令会先将 RSP 的值减去8（因为 q 表示四字，即8字节），

  ◦ RSP 指向的地址是内存中的一个位置，在x86 - 64架构下，内存是以字节编址。就是一个字节一个地址

  + ![屏幕截图 2025-05-15 163420](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20163420.png)

![屏幕截图 2025-05-15 162443](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20162443.png)

+ 就是说我把那个就比如这是一个 hello 点 c 的程序吧。然后就是我把它进行编译，然后它就是编译之后的文件是 hello 点 s，然后存储在磁盘中，然后现在我从磁盘中，把它加载到了内存中。然后它这个零零零零零六 da 就是闷函数在内存中的入口地址，对吗？然后第二个问题，这个 e 八四幺零零零零零零零是它后面的这个指令的那个，译码吗？就是 184100000 是 callq 741 multi store 这个指令的二进制形式，是吗？然后这个 6FB 是这条指令在内存中的地址，对吗？

+ 你的理解基本正确：

  • 0x000006da 通常是 main 函数在内存中的入口地址，当程序加载到内存后，操作系统会将程序的代码和数据等映射到内存中，main 函数就有了对应的内存地址。

  • e8 41 00 00 00 是 callq 741 <multstore> 这条指令的机器码，也就是你说的二进制形式。e8 是操作码，后面的 41 00 00 00 是相对偏移量，用于计算调用 multstore 函数的目标地址。

  • 0x6fb 是 callq 这条指令在内存中的地址。当程序执行到这条指令时，会根据指令中的信息跳转到 multstore 函数执行，同时会将下一条指令的地址（这里是 0x700 处指令的地址）压入栈中，以便 multstore 函数执行完毕后能返回继续执行后续代码。

# 数组的分配与访问

+ char A[8]  char A[i]=A+i

+ int A[8]     int A[i]=A+4i

+ char \*p+1 是加一个地址

+ int \*p+1  是+4个地址

+ 数组元素两个属性

  + 元素地址，&E[i]和E+i
  + 元素内容E[i]和&（E+i）

+ int A[a]\[b]

  + &A[i]\[j]=4*(ai+j)前一个的结束是后一个的开始地址

  

  

+ ![屏幕截图 2025-05-15 192724](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20192724.png)

  + 先确定三个地址
    + 行的第一个
    + 列的第一个和最后一个

# 结构体和联合体

+ 结构体元素访问都是结构体的起始地址加上偏移量
+ 数据对齐，数组都要考虑数据对齐，必须倍数
  + ![屏幕截图 2025-05-15 194445](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20194445.png)
  + ![屏幕截图 2025-05-15 194505](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20194505.png)
+ 联合体，互斥，
+ 比如拿二叉树举例子
  + 内部节点没数据，就两个指针
  + 叶子是个double数组
  + ![屏幕截图 2025-05-15 194751](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20194751.png)
  + 问题是无法分辨叶子和内部
  + 解决是加上枚举
  + ![屏幕截图 2025-05-15 194804](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20194804.png)
+ 联合体还能访问不同数据类型的位模式
  + 比如float和long的转换，可以不用转换，存是存long的位数，访问还是原先的float
  + ![屏幕截图 2025-05-15 194924](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20194924.png)

# 缓冲区溢出

+ ![屏幕截图 2025-05-15 221319](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20221319.png)
+ 数组的输入是没有检查的，get无法判断能不能有足够的空间来存储
+ 写越界了就会覆盖原有的信息
+ 就是缓冲区溢出，就是本来应该写到缓冲区的，结果写多了

### 解决方法

+ 栈随机化
  + 就是每次执行的地址空间不一样
  + adress space layout random 地址空间分布随机化 ASLR
+ 栈破坏检测
  + 金丝雀值
  + 只读，fs40存储的就是
  + 写完数据到下一条之前会异或金丝雀值看看有没有被修够啊
  + ![屏幕截图 2025-05-15 222644](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20222644.png)
  + ![屏幕截图 2025-05-15 222650](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-15%20222650.png)
+ 限制可执行区域
  + 原先是可读可执行
  + 现在是可执行有硬件控制
  + 