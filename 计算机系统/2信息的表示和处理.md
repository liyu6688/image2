![b8a7b208fd7497a15b48147a657a6c0](https://cdn.jsdelivr.net/gh/liyu6688/images@main/b8a7b208fd7497a15b48147a657a6c0.jpg)

![8e0973fa99a75df503b99b0487dd714](https://cdn.jsdelivr.net/gh/liyu6688/images@main/8e0973fa99a75df503b99b0487dd714.jpg)

![61b62af4c855605960625a3d9eab217](https://cdn.jsdelivr.net/gh/liyu6688/images@main/61b62af4c855605960625a3d9eab217.jpg)

# 8

+ 明确一点，有符号数在计算机中是按照补码来存储的
+ 正数的补码就是他本身，负数的是正数全部取反然后加一，就得到了补码
+ 补码叫two’s complete
+ “字长”通常指的是CPU一次能处理的数据的位数，例如32位（4字节）或64位（8字节）。在计算机体系结构中，字长也通常与CPU的寄存器大小和内存地址空间的大小有关。

  对于64位的电脑，其虚拟地址空间通常也是64位的。这意味着理论上它可以寻址 264 个不同的地址。实际上，由于硬件和操作系统的设计，这个数字可能会小一些，但通常远远大于 4*GB*（即 232 字节），这是32位系统通常寻址的地址空间上限。

# 信息的存储

+ 内存里面都是一个字节一个地址，用16进制表示

+ 所有地址的集合叫虚拟地址空间

+ ==字长决定了虚拟地址空间的大小==

+ 64和32位的区别还是在于编译的不同

+ ![屏幕截图 2025-05-10 190516](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20190516.png)

  ![屏幕截图 2025-05-10 194804](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20194804.png)

  ![屏幕截图 2025-05-10 190612](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20190612.png)

![屏幕截图 2025-05-11 165100](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20165100.png)

![屏幕截图 2025-05-11 165932](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20165932.png)

# 信息的表示

+ c语言中字符串以null结尾
+ show_bytes表是字符在内存中的存储信息
+ ![屏幕截图 2025-05-11 170351](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20170351.png)
+ 这个图片里面显示的数字是ASCII

### 布尔代数定义的几种运算

##### 位运算

+ 与或非异或
+ ![屏幕截图 2025-05-11 170630](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20170630.png)
+ c语言支持布尔运算的位运算
+ 16进制的位运算转化成二进制来运算
+ 位运算实现掩码运算，位运算得到特定的位序列
  + 想要得到操作数最低有效字节的值
  + ![屏幕截图 2025-05-11 171017](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20171017.png)

##### 逻辑运算

![屏幕截图 2025-05-11 171124](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20171124.png)

### 位移运算

+ <<左移，添加0
+ \>>右移
  + 逻辑右移，无符号数，添加0
  + 算术右移，有符号数，添加0/1

# 整数的表示

![屏幕截图 2025-05-11 184314](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20184314.png)

##### 计算机对无符号数的编码

+ binary to unsign
+ 权重
+ ![屏幕截图 2025-05-11 184557](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20184557.png)

##### 计算机对有符号的编码

+ 好好看看，记得他是补码，不是你想象得到那种
+ 负权重

![屏幕截图 2025-05-11 184647](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20184647.png)

![屏幕截图 2025-05-11 185011](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20185011.png)

![屏幕截图 2025-05-11 184733](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20184733.png)

##### 有符号和无符号数的转换

+ c语言中的强制转换
+ ![屏幕截图 2025-05-11 185347](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20185347.png)
+ ![屏幕截图 2025-05-11 190529](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20190529.png)
+ ![屏幕截图 2025-05-11 190441](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20190441.png)
+ ![屏幕截图 2025-05-11 190513](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20190513.png)
+ 

# 整数的运算

### 计算机计算117-115的时候就是，117转换成二进制，-115也转换成二进制但这个二进制不是115的二进制然后前面加一，而是以计算机的存储那个来转换是吗

是的，你的理解基本正确。在计算机中，负数的表示方式与正数不同。计算机通常使用**补码（Two's Complement）**来表示负数。让我们详细解释一下这个过程。

#### 1. **正数的二进制表示**

对于正数，计算机直接使用其二进制表示。例如，117 的二进制表示如下：

- **117 的二进制**：

  11710=011101012

#### 2. **负数的二进制表示（补码）**

对于负数，计算机使用补码来表示。补码的计算步骤如下：

1. **取反（One's Complement）**：将数字的二进制表示取反（0 变 1，1 变 0）。
2. **加 1**：在取反后的结果上加 1。

例如，-115 的补码表示如下：

- **115 的二进制**：

  11510=011100112

- **取反**：

  011100112→100011002

- **加 1**：

  100011002+1=100011012

因此，-115 的补码表示为：

100011012

### 计算机会遇到有符号的数西安转换成无符号的数字来表示

![屏幕截图 2025-05-11 191443](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20191443.png)

### 计算机计算遇到不同的长度时

##### 位数少的扩展成位数多的补零

+ 无符号数

![屏幕截图 2025-05-11 191515](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20191515.png)

+ 有符号数
  + 正数补零负数补1
  + ![屏幕截图 2025-05-11 191755](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20191755.png)

##### 较大数据类型转换成较小数据类型的情况

+ 会改变原来的数值
+ 类似于通过取模的方法得到
+ 无符号数
  + ![屏幕截图 2025-05-11 192117](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20192117.png)![屏幕截图 2025-05-11 191951](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20191951.png)
+ 有符号数
  + 先把二进制看成无符号数
  + 然后正常截位
  + 然后结果转换成有符号数
  + ![屏幕截图 2025-05-11 192202](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20192202.png)

### 计算溢出

+ 八位，255只能表示到255+1就是0

##### 无符号数的加法运算溢出

+ 下面是，u表示 无符号数，w表示数字是w个二进制位
+ ![屏幕截图 2025-05-11 192647](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20192647.png)

+ 溢出判断

+ ![屏幕截图 2025-05-11 193509](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20193509.png)

##### 有符号数的加法运算溢出

![屏幕截图 2025-05-11 193916](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20193916.png)

![屏幕截图 2025-05-11 193943](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20193943.png)

+ 这个例子中，第一个的1被判定为那个负号的负权重
+ 判断溢出
+ ![屏幕截图 2025-05-11 194235](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-11%20194235.png)



### 减法运算

+ 加法逆元

+ ![屏幕截图 2025-05-13 155222](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-13%20155222.png)

  ![屏幕截图 2025-05-13 155325](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-13%20155325.png)

### 乘法运算

乘法可以转换成移位和加减法

![屏幕截图 2025-05-13 175312](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-13%20175312.png)

##### 无符号数乘法

+ 两个w位的无符号数相乘，结果是2w，但要求是w，所以取后w位，所以除以2^w^取余数
+ ![屏幕截图 2025-05-13 174604](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-13%20174604.png)

##### 补码乘法

+ 只是比无符号数多一步

+ 把无符号数转换成补码

+ ![屏幕截图 2025-05-13 175016 - 副本](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-13%20175016%20-%20%E5%89%AF%E6%9C%AC.png)

  ![屏幕截图 2025-05-13 175201 - 副本](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-13%20175201%20-%20%E5%89%AF%E6%9C%AC.png)

### 除法运算

![屏幕截图 2025-05-13 181930](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-13%20181930.png)

![屏幕截图 2025-05-13 182009](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-13%20182009.png)

![屏幕截图 2025-05-13 181943](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-13%20181943.png)

# 浮点数

