+ 2021 英伟达 CPU ARM 比x86搞 grace
+ 虚拟内存跟
  + 进程管理中fork 进程，copy on write
  + 缺页 page fault handle

+ 内存存储的是正在运行的数据和程序
  + 但是，内存泄露，内存溢出
+ 机械硬盘一定带磁盘
+ 固态硬盘flash
+ 管理虚拟内存的技术，分页机制
+ 虚拟内存分成跟小的单位叫虚拟项
+ 物理内存分成页框
+ 过程
  + CPU带着虚拟内存地址给内存管理单元mmu，问翻译后备缓存区tlb，给他对应着的映射页表tle，得到物理地址pa，给cache，有就给数据，没有查内存，就是拿取数据的那部分内容了

# 过程

+ 先得到物理地址，
  + CPU带着线性地址（也就是虚拟地址，内含虚拟页号），给mmu，先查tlb transfation lookaside buffer也就是页表的缓存，
  + 没有就查页表，页表在物理内存中，
  + 以上就得到了pte 页表条目
  + 检查Pte的有效位，有效，拿到物理页号ppn，拼接页内偏移，得到物理地址
  + 无效就是缺页 page fault，触发缺页异常
    + CPU触发缺页异常，停止进程，进入内核态，执行缺页处理程序
      + 从磁盘加载到物理内存，更新状态
      + 从CPU带来线性地址重新来一遍
      + 要是虚拟也直接超出地址访问空间停止进程，比如数组越界
  + 就得到了物理地址
+ 然后用物理地址查数据，cash命中和内存命中

![屏幕截图 2025-06-19 171946](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-06-19%20171946.png)

# 那在tlb中，虚拟页数13位，威力页数只有8位，那不就有些虚拟地址超过威力地址了吗

这里需要先明确几个概念间的关系，帮你梳理清楚为什么虚拟页号位数和物理页号位数不同，以及不会出现 “虚拟地址超物理地址” 的矛盾，拆解如下：

### 一、核心概念区分

- **虚拟地址 & 物理地址**：
  - 虚拟地址是程序里用的 “逻辑地址”，长度由系统决定（题目里是 24 位 ）；
  - 物理地址是实际访问内存的 “硬件地址”，长度由内存硬件决定（题目里是 19 位 ）。
  - 二者通过 **页表 / TLB** 做 “虚拟页→物理页” 映射，再拼接 “页内偏移” 完成转换。
- **虚拟页号（VPN）& 物理页号（PPN）**：
  - VPN 是虚拟地址里 “页” 的编号（题目里虚拟地址 24 位，页内偏移 11 位 → VPN 占 13 位 ）；
  - PPN 是物理地址里 “页框” 的编号（题目里物理地址 19 位，页内偏移 11 位 → PPN 占 8 位 ）。

### 二、“位数差异” 的本质：虚拟空间≠物理空间

虚拟地址空间（程序能看到的 “假内存”）和物理地址空间（实际硬件内存）**大小可以不同**：

- 题目里虚拟地址 24 位 → 虚拟空间大小是 \(2^{24}\) 字节（约 16MB ）；
- 物理地址 19 位 → 物理空间大小是 \(2^{19}\) 字节（约 512KB ）。

**TLB 的作用**：把 “大虚拟空间里的常用页”，映射到 “小物理空间里的实际页框” 。 → 虽然 VPN（13 位）能表示 \(2^{13}=8192\) 个虚拟页，但物理空间只能存 \(2^8=256\) 个物理页框。 → 这意味着 **虚拟空间是 “逻辑上的大空间”，物理空间是 “硬件实际的小空间”** ，操作系统会通过 “页置换”（比如把不用的页换到磁盘）管理这种差异，保证程序正常运行。

### 三、“虚拟地址超物理地址” 的矛盾？不存在的！

虚拟地址转物理地址时，**不是直接 “截断 / 扩展” 位数**，而是靠 “页表映射” 决定物理页框：

1. 虚拟地址拆分：`虚拟地址 = VPN（13位） + 页内偏移（11位）`
2. TLB / 页表查询：把 `VPN` 映射成 `PPN（8位）`
3. 物理地址拼接：`物理地址 = PPN（8位） + 页内偏移（11位）` → 总长度 19 位（符合物理地址位数 ）

**举个例子**：

- 虚拟地址 `VPN=0x123`（13 位），页内偏移 `0x456`（11 位）
- 页表映射 `VPN=0x123 → PPN=0x78`（8 位）
- 物理地址 = `0x78`（8 位） + `0x456`（11 位） → 拼接成 19 位物理地址，不会超物理地址范围。

### 四、背后的操作系统逻辑：虚拟内存管理

操作系统用 **虚拟内存技术** 让程序以为自己有 “超大内存”，实际靠：

- **页表映射**：把虚拟页动态映射到物理页框（物理页不够时，换出到磁盘 ）。
- **地址转换**：CPU 通过 TLB / 页表自动完成虚拟→物理地址转换，程序感知不到物理内存的限制。

→ 所以，“VPN 位数＞PPN 位数” 是正常设计，体现了 “虚拟空间的逻辑扩展性” 和 “物理空间的硬件限制” 的平衡。