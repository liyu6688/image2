# 指令系统结构

+ 链接软件和硬件

+ 软件根据他来写

+ 硬件根据他来设计

+ instruction set architect  ISA

+ Y86，自定义的一个简单的系统

+ 可见状态

  + 就是指令能修改处理器的一些部分，比如内存，状态码，条件码

+ 条件码，条件码寄存器

+ 指令类型

  + 分为指令代码
  + 功能

+ 指令分为

  + 指令类型
  + 寄存器指示符字节

  ![屏幕截图 2025-05-16 002112](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20002112.png)

+ ![屏幕截图 2025-05-16 002838](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20002838.png)

+ ![屏幕截图 2025-05-16 014314](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20014314.png)

### 一些指令

##### move

![屏幕截图 2025-05-16 002810](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20002810.png)

##### 整数操作指令

![屏幕截图 2025-05-16 002908](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20002908.png)

##### 跳转指令

![屏幕截图 2025-05-16 002923](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20002923.png)

##### 条件传送

![屏幕截图 2025-05-16 002933](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20002933.png)

##### 其他

![屏幕截图 2025-05-16 002948](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20002948.png)

### 指令转换成二进制(但感觉是16进制，二进制哪里有4)

+ 指令代码和功能一个字节，感觉就是16进制，四个二进制一个16进制，两个八位就是一个字节正好
+ 寄存器的两个编码是一个字节
+ 指令的偏移量是8位
+ 不够补0
+ 小端法
+ ![屏幕截图 2025-05-16 003024](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20003024.png)
+ ![屏幕截图 2025-05-16 003057](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20003057.png)

### 状态码

+ aok 一切正常
+ hlt 遇到中断
+ adr 错误地址
+ ins 指令错了

![屏幕截图 2025-05-16 003110](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20003110.png)

# 数字电路与处理器设计

+ 寄存器文件，寄存器堆，寄存器集合

### 减法的实现过程，寄存器和alu串联

+ ![屏幕截图 2025-05-16 010416](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20010416.png)

### 硬件描述语言hard description language

+ verilog
+ vhdl

现在的逻辑电路很复杂，就没法画了，就写hdl，然后跟编译类似成电路图，电子设计自动化 electric design automatic软件

+ ![屏幕截图 2025-05-16 010651](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20010651.png)

##### d寄存器的verilog

![屏幕截图 2025-05-16 013754](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20013754.png)

+ always表示时钟c上升沿的时候
+ ![屏幕截图 2025-05-16 014148](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20014148.png)

### 寄存器读写的具体过程

![屏幕截图 2025-05-16 010536](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20010536.png)

+ 能不能写we
+ 往哪里写addr，就是地址线，因为只有15个所以四位够了
+ 写什么，或者读什么，data数据线，in和out
+ clock时钟
+ reset 重置
+ ![屏幕截图 2025-05-16 010822](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20010822.png)
+ 就是add和we共同决定往哪个里面能写
+ 寄存器内部的存储功能是d触发器实现的
+ d里面有个锁存器
+ ![屏幕截图 2025-05-16 013625](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20013625.png)

### 多路选择器的实现

+ 就是选择一条路输出
+ 一般是多输入，一条输出
+ 寄存器上面那个图里面就是输出同一个寄存器里面的内容
+ ![屏幕截图 2025-05-16 011217](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20011217.png)

### 里面门电路的实现

##### 电路分类

+ 组合逻辑电路
+ 时序逻辑电路
+ 区别在有没有存储器，计时有没有记忆，只跟当前的状态有关还是之前也有

##### 逻辑门的分类

+ 与或非异或
+ ![屏幕截图 2025-05-16 010830](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20010830.png)

#### 门电路更具体的实现

+ 就是晶体管电路
+ 晶体管，就是基于CMOS的工艺
  + n
  + p管
  + 都是三个端口
  + ![屏幕截图 2025-05-16 010948](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20010948.png)
+ 比如非门的实现
+  ![屏幕截图 2025-05-16 013237](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20013237.png)
+ 漏极连在一起作为输出端口
+ 输入端口
+ vdd电源
+ vss接地
+ 高电平n通，再下面连着地，低电平输出

# Y86-64的顺序实现

### 指令的执行顺序

+ 取指fetch
+ 译码 decode
  + 就是选择寄存器文件里面的寄存器，也就是从寄存器文件里面读取数据![屏幕截图 2025-05-16 024242](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20024242.png)
+ 执行 execute
  + alu
    + 算术运算
    + 内存引用计算实际地址
    + push pop
+ 访存 memory
  + 内存读写
+ 写回 wb
  + 运算结构写回寄存器
+ 更新pc update

### 减法

![屏幕截图 2025-05-16 024347](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20024347.png)

+ 取指令会判断他有没有寄存器
+ 译码，从寄存器里面取数字
+ 执行al==u，同时alu会根据结果设置条件码==cc
+ 访存，不用写到内存
+ 写回，得数写回寄存器
+ 更新指令pc

### irmovq

![屏幕截图 2025-05-16 024715](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20024715.png)

+ 不用从寄存器读数字，没有译码
+ 执行是直接数+0

### rmovq

![屏幕截图 2025-05-16 024905](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20024905.png)

+ 执行这个阶段就是用alu，而不是执行指令的功能

### pushq

![屏幕截图 2025-05-16 025005](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20025005.png)

+ push是压栈，所以一定是要读取rsp的
+ 取指令
+ 译码，读两个数据
+ 执行，是计算数值应该放入的地址，注意这里跟rsp没关系，他只是说热水瓶里面存储着栈顶的地址，应该是还没更新到rsp
+ 访存，把数字写入内存
+ 写回，就是忘记存起里面写东西，rsp改变了，更新他

### 跳转

+ 就是要跳转到后面那个地址
+ 取指
+ 译码，没有从寄存器读东西，没有操作
+ 执行，alu换个硬件cond，一个硬件单元，根据条件码和指令来控制是否要跳转
+ ![屏幕截图 2025-05-16 025724](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20025724.png)

# Y86-64处理器硬件结构

### 取指

![屏幕截图 2025-05-16 030528](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20030528.png)

+ 从pc里面的地址开始，从内存里取10位，规定最长10位
+ 第一个byte是操作码，硬件split来处理，
  + 分为指令代码和指令功能
  + 要看一下这个指令代码是否有效
  + 根据指令判断需不需要寄存器和立即数
  + 就能知道指令长度
  + pc需要增加的数值也就有了
  + ra和rb是半个字节，来存寄存器
  + 后面8个存立即数

### 译码

![屏幕截图 2025-05-16 035436](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20035436.png)

+ ra和rb存储寄存器的地方和icode一起确定要读取的寄存器
+ 需要icode，比如push，可以通过icode来确定要不要rsp

### 执行

![屏幕截图 2025-05-16 035701](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20035701.png)

+ 根据ifun决定alufun
+ alu仅仅再算术逻辑单元的时候设置条件码，所以有setcc，根据icode决定

### 访存

![屏幕截图 2025-05-16 040036](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20040036.png)

### 写回

![屏幕截图 2025-05-16 040253](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20040253.png)

### 更新pc

![屏幕截图 2025-05-16 040309](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20040309.png)

# 流水线的通用原理

# 流水线的硬件结构

+ 电路重定向
  + 改变状态不变行为
  + 把信号存储到一个寄存器，指令开始之前预测pc

# 数据冒险

+ 译码的时候跟他前面其他的指令比较一下，看看有没有重了的id，有就等着，插入气泡
+ 数据旁路
+ 停止流水线和数据旁路一起

# 控制冒险

+ 停止
+ 分支预测
+ ![屏幕截图 2025-05-16 043120](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-16%20043120.png)

# Y86-64的流水实现

# 流水线的控制逻辑

九和十在看