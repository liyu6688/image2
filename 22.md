# 8

+ gnu 一个基金会想创建的操作系统，完全自由基于Unix
+ gcc gnu compiler collection 那个操作系统中集成的编译器
+ 一些编译器，vim emacs
+ 一个字是多大呢，32位的电脑就是四个字节，64位的就是8个字节
+ 每个寄存器都有自己的名字
+ 总线通常也是传输这些大小的字

# hello.c的历程

+ 创建
+ 编译
  + 预处理
  + 编译
  + 汇编
  + 链接
  + 最终得到可执行文件hello就放在磁盘上了
+ 执行
+ 结束

### 创建就是写

### 编译

+ gcc -o hello hello.c
+ ![屏幕截图 2025-05-10 083952](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20083952.png)

##### 预处理 pre processor

include   define  elif替换成文本

##### 编译

+ 词法分析
+ 语法分析
+ 语义分析
+ 中间代码生成和优化

##### 汇编

+ 根据指令集
+ 翻译成机器指令
+ 并且要讲这些机器指令分类打包
+ 可重定向文件hello.o ,成为二进制

##### 链接

+ 合并文件，所以为重定向文件
+ 感觉像是把一堆文件夹里面的文件弄在一起执行，类似于吧一个程序中的多个文件结合在一起是吗，对的

##### 6. **为什么需要链接**

即使预处理已经将头文件的内容插入到源代码中，编译器和汇编器仍然无法解决以下问题：

- **函数和变量的定义**：头文件通常只包含函数和变量的声明，而不是定义。例如，`<stdio.h>`中声明了`printf`函数，但`printf`函数的实现代码在标准C库中。链接器需要将这些函数的定义链接到最终的可执行文件中。
- **多个源文件的组合**：一个大型项目通常由多个源文件组成，每个源文件编译成一个目标文件。链接器需要将这些目标文件组合在一起，解决它们之间的符号引用问题。
- **库文件的使用**：项目中可能会使用标准库或第三方库。链接器需要将这些库文件中的代码和符号链接到最终的可执行文件中。

### 执行

+ shell中开头不是他的命令，就是可执行文件，因为他会把第一个执行
+ ./hello
+ 往shell里面输入./hello，这个hello 的历程，把命令执行，然后放到内存
+ ![屏幕截图 2025-05-10 084619](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20084619.png)
+ 然后根据命令下一步，把磁盘中的可执行文件和数据加载到内存，开始执行main
+ 

![屏幕截图 2025-05-10 084950](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20084950.png)

![屏幕截图 2025-05-10 085022](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20085022.png)

+ 所以他信息搬运很多，所以要缩短时间效率

+ ![屏幕截图 2025-05-10 090352](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20090352.png)

  ![屏幕截图 2025-05-10 090403](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20090403.png)

##### 执行中过程

+ 软件无法直接控制硬件

+ 防止失控乱用
+ 操作系统同一控制
+ 下面是对软件和硬件的抽象
+ ![屏幕截图 2025-05-10 093827](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20093827.png)

+ shell这个软件程序有控制权，输入./hello
+ 控制权给操作系统，内存调用进来
+ 控制权给hello这个软件程序，
+ 最终还给shell恢复shell的上下文
+ 上下文是程序的状态信息，pc和寄存器的值，内存中的内容等等还有他的线程
+ ![屏幕截图 2025-05-10 091259](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20091259.png)

# 虚拟内存

+ 对每个进程提供一个假象，独立占用内存，他们看到的内存是一样的，虚拟地址空间
+ 下面是linux的虚拟内存地址

![屏幕截图 2025-05-10 092000](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20092000.png)

# 提高程序运行时间

![屏幕截图 2025-05-10 092656](./../c%E7%9B%98%E7%A7%BB%E8%BF%87%E6%9D%A5%E7%9A%84/%E5%9B%BE%E7%89%87/Screenshots/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20092656.png)

![屏幕截图 2025-05-10 092726](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20092726.png)

+ 只靠提高硬件，k趋近于无穷才能到两倍这需要优化大部分组件
  + 一个芯片集成多个CPU四核就是四个CPU，他们共用三级cache
  + ![屏幕截图 2025-05-10 093323](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20093323.png)
+ 线程并发 thread -level concurrency
+ 指令级并行 instruction-level parallelism
  + 同时执行多条指令，注意不是线程
  + 感觉像是流水线
+ 单指令，多数据并行 single-instruction mutiple-data parallelism
  + 一条指令产生多条并行的操作
  + simd指令
  + 多是为了提高视频和声音处理
+ 超线程hyper threading ，同时多线程
  + ![屏幕截图 2025-05-10 093502](https://cdn.jsdelivr.net/gh/liyu6688/images@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-05-10%20093502.png)